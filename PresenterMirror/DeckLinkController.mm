/* -LICENSE-START-
 ** Copyright (c) 2011 Blackmagic Design
 **
 ** Permission is hereby granted, free of charge, to any person or organization
 ** obtaining a copy of the software and accompanying documentation covered by
 ** this license (the "Software") to use, reproduce, display, distribute,
 ** execute, and transmit the Software, and to prepare derivative works of the
 ** Software, and to permit third-parties to whom the Software is furnished to
 ** do so, all subject to the following:
 ** 
 ** The copyright notices in the Software and this entire statement, including
 ** the above license grant, this restriction and the following disclaimer,
 ** must be included in all copies of the Software, in whole or in part, and
 ** all derivative works of the Software, unless such copies or derivative
 ** works are solely in the form of machine-executable object code generated by
 ** a source language processor.
 ** 
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 ** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 ** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 ** DEALINGS IN THE SOFTWARE.
 ** -LICENSE-END-
 */

#include "DeckLinkController.h"

using namespace std;

IDeckLinkGLScreenPreviewHelper** globalScreenPreviewHelper;

HRESULT DeckLinkScreenPreviewCallback::DrawFrame(/* in */ IDeckLinkVideoFrame *theFrame)
{
	if(globalScreenPreviewHelper && *globalScreenPreviewHelper)
		return (*globalScreenPreviewHelper)->SetFrame(theFrame);
	else
		return E_FAIL; // picked something
}





DeckLinkController::DeckLinkController(CapturePreviewAppDelegate* delegate)
	: uiDelegate(delegate), selectedDevice(NULL), deckLinkInput(NULL), 
	screenPreviewHelper(NULL), supportFormatDetection(false), currentlyCapturing(false)
{
	globalScreenPreviewHelper = &screenPreviewHelper;
}


DeckLinkController::~DeckLinkController()
{
	vector<IDeckLink*>::iterator it;
	
	// Release screen preview
	if (screenPreviewHelper != NULL)
	{
		screenPreviewHelper->Release();
		screenPreviewHelper = NULL;
	}
		
	// Release the IDeckLink list
	for(it = deviceList.begin(); it != deviceList.end(); it++)
	{
		(*it)->Release();
	}
}


bool		DeckLinkController::init(NSView *previewView)
{
	IDeckLinkIterator*	deckLinkIterator = NULL;
	IDeckLink*			deckLink = NULL;
	bool				result = false;
	
	// Create an iterator
	deckLinkIterator = CreateDeckLinkIteratorInstance();
	if (deckLinkIterator == NULL)
	{
		[uiDelegate showErrorMessage:@"This application requires the Desktop Video drivers installed." title:@"Please install the Blackmagic Desktop Video drivers to use the features of this application."];
		goto bail;
	}
	
	// List all DeckLink devices
	while (deckLinkIterator->Next(&deckLink) == S_OK)
	{
		// Add device to the device list
		deviceList.push_back(deckLink);
	}
	
	if (deviceList.size() == 0)
	{
		[uiDelegate showErrorMessage:@"You will not be able to use the features of this application until a Blackmagic device is installed." title:@"This application requires at least one Blackmagic device."];
		goto bail;
	}
	
	screenPreviewHelper = CreateOpenGLScreenPreviewHelper();

	result = true;
	
bail:
	if (deckLinkIterator != NULL)
	{
		deckLinkIterator->Release();
		deckLinkIterator = NULL;
	}
	
	return result;
}


int			DeckLinkController::getDeviceCount()
{
	return deviceList.size();
}


NSMutableArray*		DeckLinkController::getDeviceNameList()
{
	NSMutableArray*		nameList = [NSMutableArray array];
	int					deviceIndex = 0;
	
	while (deviceIndex < deviceList.size())
	{		
		CFStringRef	cfStrName;
		
		// Get the name of this device
		if (deviceList[deviceIndex]->GetDisplayName(&cfStrName) == S_OK)
		{		
			[nameList addObject:(__bridge NSString *)cfStrName];
			CFRelease(cfStrName);
		}
		else
		{
			[nameList addObject:@"DeckLink"];
		}

		deviceIndex++;
	}
	
	return nameList;
}


bool		DeckLinkController::selectDevice(int index)
{
	IDeckLinkAttributes*			deckLinkAttributes = NULL;
	IDeckLinkDisplayModeIterator*	displayModeIterator = NULL;
	IDeckLinkDisplayMode*			displayMode = NULL;
	bool							result = false;

	// Check index
	if (index >= deviceList.size())
	{
		[uiDelegate showErrorMessage:@"This application was unable to select the device." title:@"Error getting selecting the DeckLink device."];
		goto bail;
	}
	
	// A new device has been selected.
	// Release the previous selected device and mode list
	if (deckLinkInput != NULL)
		deckLinkInput->Release();
	
	while(modeList.size() > 0)
	{
		modeList.back()->Release();
		modeList.pop_back();
	}
	
	
	// Get the IDeckLinkInput for the selected device
	if ((deviceList[index]->QueryInterface(IID_IDeckLinkInput, (void**)&deckLinkInput) != S_OK))
	{
		[uiDelegate showErrorMessage:@"This application was unable to obtain IDeckLinkInput for the selected device." title:@"Error getting setting up capture."];
		deckLinkInput = NULL;
		goto bail;
	}
	
	//
	// Retrieve and cache mode list	
	if (deckLinkInput->GetDisplayModeIterator(&displayModeIterator) == S_OK)
	{
		while (displayModeIterator->Next(&displayMode) == S_OK)
			modeList.push_back(displayMode);

		displayModeIterator->Release();
	}
	
	//
	// Check if input mode detection format is supported.
	
	supportFormatDetection = false;	// assume unsupported until told otherwise
	if (deviceList[index]->QueryInterface(IID_IDeckLinkAttributes, (void**) &deckLinkAttributes) == S_OK)
	{	
		if (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &supportFormatDetection) != S_OK)
			supportFormatDetection = false;
		
		deckLinkAttributes->Release();
	}
	
	result = true;
	
bail:
	return result;
}

NSMutableArray*		DeckLinkController::getDisplayModeNames()
{
	NSMutableArray*		modeNames = [NSMutableArray array];
	int					modeIndex;
	CFStringRef			modeName;
	
	for (modeIndex = 0; modeIndex < modeList.size(); modeIndex++)
	{			
		if (modeList[modeIndex]->GetName(&modeName) == S_OK)
		{
			[modeNames addObject:(__bridge NSString *)modeName];
			CFRelease(modeName);
		}
		else 
		{
			[modeNames addObject:@"Unknown mode"];
		}
	}
	
	return modeNames;
}

bool		DeckLinkController::isFormatDetectionEnabled()
{
	return supportFormatDetection;
}

bool		DeckLinkController::isCapturing()
{
	return currentlyCapturing;
}

bool		DeckLinkController::startCapture(int videoModeIndex)
{
	BMDVideoInputFlags		videoInputFlags;
	
	// Enable input video mode detection if the device supports it
	videoInputFlags = supportFormatDetection ? bmdVideoInputEnableFormatDetection : bmdVideoInputFlagDefault;
	
	// Get the IDeckLinkDisplayMode from the given index
	if ((videoModeIndex < 0) || (videoModeIndex >= modeList.size()))
	{
		[uiDelegate showErrorMessage:@"An invalid display mode was selected." title:@"Error starting the capture"];
		return false;
	}
	
	// Set the screen preview
	deckLinkInput->SetScreenPreviewCallback(screenPreviewCallback);
	
	// Set capture callback
	deckLinkInput->SetCallback(this);
	
	// Set the video input mode
	if (deckLinkInput->EnableVideoInput(modeList[videoModeIndex]->GetDisplayMode(), bmdFormat8BitYUV, videoInputFlags) != S_OK)
	{
		[uiDelegate showErrorMessage:@"This application was unable to select the chosen video mode. Perhaps, the selected device is currently in-use." title:@"Error starting the capture"];
		return false;
	}
	
	// Start the capture
	if (deckLinkInput->StartStreams() != S_OK)
	{
		[uiDelegate showErrorMessage:@"This application was unable to start the capture. Perhaps, the selected device is currently in-use." title:@"Error starting the capture"];
		return false;
	}
	
	currentlyCapturing = true;
	
	return true;
}

void		DeckLinkController::stopCapture()
{
	// Stop the capture
	deckLinkInput->StopStreams();
	
	// Delete capture callback
	deckLinkInput->SetCallback(NULL);
	
	currentlyCapturing = false;
}


HRESULT		DeckLinkController::VideoInputFormatChanged (/* in */ BMDVideoInputFormatChangedEvents notificationEvents, /* in */ IDeckLinkDisplayMode *newMode, /* in */ BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{
	UInt32				modeIndex = 0;
	
	@autoreleasepool
	{
		
		
		// Restart capture with the new video mode if told to
		if ([uiDelegate shouldRestartCaptureWithNewVideoMode] == YES)
		{
			// Stop the capture
			deckLinkInput->StopStreams();
			
			// Set the video input mode
			if (deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), bmdFormat8BitYUV, bmdVideoInputEnableFormatDetection) != S_OK)
			{
				[uiDelegate stopCapture];
				[uiDelegate showErrorMessage:@"This application was unable to select the new video mode." title:@"Error restarting the capture."];
				goto bail;
			}
			
			// Start the capture
			if (deckLinkInput->StartStreams() != S_OK)
			{
				[uiDelegate stopCapture];
				[uiDelegate showErrorMessage:@"This application was unable to start the capture on the selected device." title:@"Error restarting the capture."];
				goto bail;
			}
		}
		
		// Find the index of the new mode in the mode list so we can update the UI
		while (modeIndex < modeList.size()) {
			if (modeList[modeIndex]->GetDisplayMode() == newMode->GetDisplayMode())
			{
				[uiDelegate selectDetectedVideoModeWithIndex: modeIndex];
				break;
			}
			modeIndex++;
		}
		
		
	bail:
		;
	}
	return S_OK;
}

HRESULT 	DeckLinkController::VideoInputFrameArrived (/* in */ IDeckLinkVideoInputFrame* videoFrame, /* in */ IDeckLinkAudioInputPacket* audioPacket)
{
	BOOL					hasValidInputSource = (videoFrame->GetFlags() & bmdFrameHasNoInputSource) != 0 ? NO : YES;
	AncillaryDataStruct		*ancillaryData = [AncillaryDataStruct new];
	
	@autoreleasepool {
	
	// Update input source label
		[uiDelegate updateInputSourceState:hasValidInputSource];
		
		// Get the various timecodes and userbits for this frame
//	getAncillaryDataFromFrame(videoFrame, bmdTimecodeVITC, &ancillaryData->vitcF1Timecode, &ancillaryData->vitcF1UserBits);
//	getAncillaryDataFromFrame(videoFrame, bmdTimecodeVITCField2, &ancillaryData->vitcF2Timecode, &ancillaryData->vitcF2UserBits);
//	getAncillaryDataFromFrame(videoFrame, bmdTimecodeRP188VITC1, &ancillaryData->rp188vitc1Timecode, &ancillaryData->rp188vitc1UserBits);
//	getAncillaryDataFromFrame(videoFrame, bmdTimecodeRP188LTC, &ancillaryData->rp188ltcTimecode, &ancillaryData->rp188ltcUserBits);
//	getAncillaryDataFromFrame(videoFrame, bmdTimecodeRP188VITC2, &ancillaryData->rp188vitc2Timecode, &ancillaryData->rp188vitc2UserBits);
		
		// Update the UI
//		[uiDelegate updateAncillaryData:ancillaryData];
	
	}
	return S_OK;
}

void	DeckLinkController::getAncillaryDataFromFrame(IDeckLinkVideoInputFrame* videoFrame, BMDTimecodeFormat timecodeFormat, NSString** timecodeString, NSString** userBitsString)
{
	IDeckLinkTimecode*		timecode = NULL;
	CFStringRef				timecodeCFString;
	BMDTimecodeUserBits		userBits = 0;
	
	if ((videoFrame != NULL) && (timecodeString != NULL) && (userBitsString != NULL)
		&& (videoFrame->GetTimecode(timecodeFormat, &timecode) == S_OK))
	{
		if (timecode->GetString(&timecodeCFString) == S_OK)
		{
			*timecodeString = [NSString stringWithString: (__bridge NSString *)timecodeCFString];
			CFRelease(timecodeCFString);
		}
		else
		{
			*timecodeString = @"";
		}
		
		timecode->GetTimecodeUserBits(&userBits);
		*userBitsString = [NSString stringWithFormat:@"0x%08X", userBits];
		
		timecode->Release();
	}
	else
	{
		*timecodeString = @"";
		*userBitsString = @"";
	}


}




